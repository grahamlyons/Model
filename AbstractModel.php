<?php

/**
 * Base class for a data model with getters, setters and validation.
 * @abstract
 */
abstract class AbstractModel {

    /**
     * The list of fields stored in the model.
     * @var array
     */
    protected $_fields;

    /**
     * The fields and values stored in the model.
     * @var array
     */
    protected $_data;

    /**
     * Filters to apply to the data.
     * @var array
     */
    protected $_filters;

    /**
     * Validators to apply to the data.
     * @var array
     */
    protected $_validators;

    /**
     * Class to use to do the validation. This can be changed
     * but it'll need to have the same API as the default Zend class.
     * @var String
     */
    protected $_validator_class = 'Zend_Filter_Input';

    /**
     * Instance of the $_validator_class variable.
     * @var instance of $_validator_class
     */
    protected $_validator;

    /**
     * The messages generated during validation.
     * @var array
     */
    protected $_messages;

    /**
     * Instantiate a new object.
     * @param array $data An associative array of fields and data values.
     * @return $this An instance of the class
     */
    public function __construct (array $data = null) {
        if ($data) {
            foreach ($data as $name => $value) {
                $this->$name = $value;
            }
        }
        return $this;
    }

    /**
     * Set a value for a data field.
     * @param string $name Name of the data field.
     * @param mixed $value The value to set.
     * @return void
     */
    public function __set ($name, $value) {
        if (in_array($name, $this->_fields)) {
            $this->_data[$name] = $value;
        }
        else {
            throw new PropertyNotFoundException("$name not found in class");
        }
    }

    /**
     * Get a value for a data field.
     * @param string $name Name of the data field.
     * @return mixed
     */
    public function __get ($name) {
        if (in_array($name, $this->_fields)) {
            return $this->_data[$name];
        }
        else {
            throw new PropertyNotFoundException("$name not found in class");
        }
    }

    /**
     * Set a string for the name of the class to use to perform the validation.
     * @param string $class Name of the class.
     * @return void
     */
    public function setValidatorClass ($class) {
        $this->_validator_class = $class;
    }

    /**
     * Test if the data in the model is valid according to the defined validation rules.
     * @return bool
     */
    public function isValid () {
        $validator = $this->getValidator();
        $validator->setData($this->_data);
        $isValid = $validator->isValid();
        if (!$isValid) {
            $this->_messages = $validator->getErrors();
        }
        return $isValid;
    }

    /**
     * Get an instantiation of the validator class.
     * @return instance of $_validator_class variable.
     */
    public function getValidator () {
        if (!$this->_validator) {
            $this->_validator = new $this->_validator_class($this->_filters, $this->_validators);
        }
        return $this->_validator;
    }

    /**
     * Get the messages, if any, generated by the validation process.
     * @return bool
     */
    public function getMessages () {
        return $this->_messages;
    }

}

/**
 * Exception for properties not found in the model
 */
class PropertyNotFoundException extends Exception { }
